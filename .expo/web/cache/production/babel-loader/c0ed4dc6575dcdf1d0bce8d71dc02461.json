{"ast":null,"code":"function _createForOfIteratorHelperLoose(o){var i=0;if(typeof Symbol===\"undefined\"||o[typeof Symbol===\"function\"?Symbol.iterator:\"@@iterator\"]==null){if(Array.isArray(o)||(o=_unsupportedIterableToArray(o)))return function(){if(i>=o.length)return{done:true};return{done:false,value:o[i++]};};throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");}i=o[typeof Symbol===\"function\"?Symbol.iterator:\"@@iterator\"]();return i.next.bind(i);}function _unsupportedIterableToArray(o,minLen){if(!o)return;if(typeof o===\"string\")return _arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);if(n===\"Object\"&&o.constructor)n=o.constructor.name;if(n===\"Map\"||n===\"Set\")return Array.from(o);if(n===\"Arguments\"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray(o,minLen);}function _arrayLikeToArray(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++){arr2[i]=arr[i];}return arr2;}import{match}from\"@reach/router/lib/utils\";import stripPrefix from\"./strip-prefix\";import normalizePagePath from\"./normalize-page-path\";var pathCache=new Map();var matchPaths=[];var trimPathname=function trimPathname(rawPathname){var pathname=decodeURIComponent(rawPathname);var trimmedPathname=stripPrefix(pathname,__BASE_PATH__).split(\"#\")[0].split(\"?\")[0];return trimmedPathname;};export var setMatchPaths=function setMatchPaths(value){matchPaths=value;};export var findMatchPath=function findMatchPath(rawPathname){var trimmedPathname=cleanPath(rawPathname);for(var _iterator=_createForOfIteratorHelperLoose(matchPaths),_step;!(_step=_iterator()).done;){var _ref=_step.value;var matchPath=_ref.matchPath;var path=_ref.path;if(match(matchPath,trimmedPathname)){return normalizePagePath(path);}}return null;};export var findPath=function findPath(rawPathname){var trimmedPathname=trimPathname(rawPathname);if(pathCache.has(trimmedPathname)){return pathCache.get(trimmedPathname);}var foundPath=findMatchPath(trimmedPathname);if(!foundPath){foundPath=cleanPath(rawPathname);}pathCache.set(trimmedPathname,foundPath);return foundPath;};export var cleanPath=function cleanPath(rawPathname){var trimmedPathname=trimPathname(rawPathname);var foundPath=trimmedPathname;if(foundPath===\"/index.html\"){foundPath=\"/\";}foundPath=normalizePagePath(foundPath);return foundPath;};","map":{"version":3,"sources":["/Users/calumharris/code/liana-moran/.cache/find-path.js"],"names":["match","stripPrefix","normalizePagePath","pathCache","Map","matchPaths","trimPathname","rawPathname","pathname","decodeURIComponent","trimmedPathname","__BASE_PATH__","split","setMatchPaths","value","findMatchPath","cleanPath","matchPath","path","findPath","has","get","foundPath","set"],"mappings":"qiCAAA,OAASA,KAAT,KAAsB,yBAAtB,CACA,MAAOC,CAAAA,WAAP,KAAwB,gBAAxB,CACA,MAAOC,CAAAA,iBAAP,KAA8B,uBAA9B,CAEA,GAAMC,CAAAA,SAAS,CAAG,GAAIC,CAAAA,GAAJ,EAAlB,CACA,GAAIC,CAAAA,UAAU,CAAG,EAAjB,CAEA,GAAMC,CAAAA,YAAY,CAAG,QAAfA,CAAAA,YAAe,CAAAC,WAAW,CAAI,CAClC,GAAMC,CAAAA,QAAQ,CAAGC,kBAAkB,CAACF,WAAD,CAAnC,CAEA,GAAMG,CAAAA,eAAe,CAAGT,WAAW,CAACO,QAAD,CAAWG,aAAX,CAAX,CAErBC,KAFqB,MAEV,CAFU,EAIrBA,KAJqB,MAIV,CAJU,CAAxB,CAMA,MAAOF,CAAAA,eAAP,CACD,CAVD,CAiBA,MAAO,IAAMG,CAAAA,aAAa,CAAG,QAAhBA,CAAAA,aAAgB,CAAAC,KAAK,CAAI,CACpCT,UAAU,CAAGS,KAAb,CACD,CAFM,CAYP,MAAO,IAAMC,CAAAA,aAAa,CAAG,QAAhBA,CAAAA,aAAgB,CAAAR,WAAW,CAAI,CAC1C,GAAMG,CAAAA,eAAe,CAAGM,SAAS,CAACT,WAAD,CAAjC,CAEA,kDAAkCF,UAAlC,mCAA8C,yBAAjCY,CAAAA,SAAiC,MAAjCA,SAAiC,IAAtBC,CAAAA,IAAsB,MAAtBA,IAAsB,CAC5C,GAAIlB,KAAK,CAACiB,SAAD,CAAYP,eAAZ,CAAT,CAAuC,CACrC,MAAOR,CAAAA,iBAAiB,CAACgB,IAAD,CAAxB,CACD,CACF,CAED,MAAO,KAAP,CACD,CAVM,CAoBP,MAAO,IAAMC,CAAAA,QAAQ,CAAG,QAAXA,CAAAA,QAAW,CAAAZ,WAAW,CAAI,CACrC,GAAMG,CAAAA,eAAe,CAAGJ,YAAY,CAACC,WAAD,CAApC,CAEA,GAAIJ,SAAS,CAACiB,GAAV,CAAcV,eAAd,CAAJ,CAAoC,CAClC,MAAOP,CAAAA,SAAS,CAACkB,GAAV,CAAcX,eAAd,CAAP,CACD,CAED,GAAIY,CAAAA,SAAS,CAAGP,aAAa,CAACL,eAAD,CAA7B,CAEA,GAAI,CAACY,SAAL,CAAgB,CACdA,SAAS,CAAGN,SAAS,CAACT,WAAD,CAArB,CACD,CAEDJ,SAAS,CAACoB,GAAV,CAAcb,eAAd,CAA+BY,SAA/B,EAEA,MAAOA,CAAAA,SAAP,CACD,CAhBM,CAyBP,MAAO,IAAMN,CAAAA,SAAS,CAAG,QAAZA,CAAAA,SAAY,CAAAT,WAAW,CAAI,CACtC,GAAMG,CAAAA,eAAe,CAAGJ,YAAY,CAACC,WAAD,CAApC,CAEA,GAAIe,CAAAA,SAAS,CAAGZ,eAAhB,CACA,GAAIY,SAAS,gBAAb,CAAiC,CAC/BA,SAAS,IAAT,CACD,CAEDA,SAAS,CAAGpB,iBAAiB,CAACoB,SAAD,CAA7B,CAEA,MAAOA,CAAAA,SAAP,CACD,CAXM","sourcesContent":["import { match } from \"@reach/router/lib/utils\"\nimport stripPrefix from \"./strip-prefix\"\nimport normalizePagePath from \"./normalize-page-path\"\n\nconst pathCache = new Map()\nlet matchPaths = []\n\nconst trimPathname = rawPathname => {\n  const pathname = decodeURIComponent(rawPathname)\n  // Remove the pathPrefix from the pathname.\n  const trimmedPathname = stripPrefix(pathname, __BASE_PATH__)\n    // Remove any hashfragment\n    .split(`#`)[0]\n    // Remove search query\n    .split(`?`)[0]\n\n  return trimmedPathname\n}\n\n/**\n * Set list of matchPaths\n *\n * @param {Array<{path: string, matchPath: string}>} value collection of matchPaths\n */\nexport const setMatchPaths = value => {\n  matchPaths = value\n}\n\n/**\n * Return a matchpath url\n * if `match-paths.json` contains `{ \"/foo*\": \"/page1\", ...}`, then\n * `/foo?bar=far` => `/page1`\n *\n * @param {string} rawPathname A raw pathname\n * @return {string|null}\n */\nexport const findMatchPath = rawPathname => {\n  const trimmedPathname = cleanPath(rawPathname)\n\n  for (const { matchPath, path } of matchPaths) {\n    if (match(matchPath, trimmedPathname)) {\n      return normalizePagePath(path)\n    }\n  }\n\n  return null\n}\n\n// Given a raw URL path, returns the cleaned version of it (trim off\n// `#` and query params), or if it matches an entry in\n// `match-paths.json`, its matched path is returned\n//\n// E.g. `/foo?bar=far` => `/foo`\n//\n// Or if `match-paths.json` contains `{ \"/foo*\": \"/page1\", ...}`, then\n// `/foo?bar=far` => `/page1`\nexport const findPath = rawPathname => {\n  const trimmedPathname = trimPathname(rawPathname)\n\n  if (pathCache.has(trimmedPathname)) {\n    return pathCache.get(trimmedPathname)\n  }\n\n  let foundPath = findMatchPath(trimmedPathname)\n\n  if (!foundPath) {\n    foundPath = cleanPath(rawPathname)\n  }\n\n  pathCache.set(trimmedPathname, foundPath)\n\n  return foundPath\n}\n\n/**\n * Clean a url and converts /index.html => /\n * E.g. `/foo?bar=far` => `/foo`\n *\n * @param {string} rawPathname A raw pathname\n * @return {string}\n */\nexport const cleanPath = rawPathname => {\n  const trimmedPathname = trimPathname(rawPathname)\n\n  let foundPath = trimmedPathname\n  if (foundPath === `/index.html`) {\n    foundPath = `/`\n  }\n\n  foundPath = normalizePagePath(foundPath)\n\n  return foundPath\n}\n"]},"metadata":{},"sourceType":"module"}